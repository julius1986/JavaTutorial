package coretutorial.Lesson10_Collections.Core.MapExample;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * Created by Yuliy on 23.12.2016.
 */

/*hashMap изначальное число элементов равно 16, лоад фактор равен 0,75 тоесть
* при загрузке на 75% число эелементов будет удвоено.
* Тоесть если у нас 10 элементов а лоад фактор 0,75 то при достижении
* 10*0,75 элементво в нашем случае если добавляется 8 элемент размер нашей
* HashMap будет удвоен и составит 10*2 = 20
* HashMap не гарантирует порядок, тоесть элементы могут выводится в
* неотсортированном виде, так же HashMap неявляется синхронизированным
* LinkedHashMap тоже самое что и HashMap разница только в том что тут элементы
* хранятся в том виде в котором они были вставлены в мапу
* TreeMap это отсортированная мапа
* ------------------------------------------------------------------------------
* Принцип работы:
* при добавлении элемента ключ, значение
* внутри мапы есть массив его ИНДЕКС будет равен хешкоду ключа & (n-1). index = hashCode(key) & (n-1)
 * Хешкод это число. После того как нам стал известен индекс массива(корзина), в него
 * помещается Нода (ключ и значение), если до этого в этой корзине уже есть
 * нода(ключь и значение), то новый ключ(который мы хотим добавить) сравнивается с существующими
 * и если они эквивалентны то значение затирается новым, а если нет то в конец последней ноды 
 * добавляется новые ключ значение тем самым образуя список.
 *
 * По сути наша мапа есть массив где хранятся списки из Node<k,v>, где нода может указывать 
 * на следующую ноду(с ключем и значением).
 * Bucket(корзина) - это единственный элемент массива HashMap. Он используется для хранения узлов (Nodes). 
 * Два или более узла могут иметь один и тот - же bucket, тоесть лежать в одной корзине. 
 * В этом случае для связи узлов используется структура данных связанный список, когда одина нода указывает на следующую.
 * Node<K,V>
 *     int hash; - это наш хеш код
 *     K key;
 *     V value;
 *     Node<K,V> next; - указатель на следующую ноду(ключ, значение), по умолчанию null.
 *     Если индекс двух нод будет одинаковый(они попадают в одну корзину), но хеш код 
 *	   двух нод	разные то next(первой ноды) будет указывать на следующую ноду.
 *     
 *     Индекс корзины для ноды считается по формуле index = hashCode(key) & (n-1) где n - рзамер массива мапы
 *     по умолчанию равен 16.  & - Побитовый(поразрядный) оператор И
 *	   	initCapacity = 16;
 *		loadFactory = 0.75;
 *		при достижении лимита количество корзинок увеличивается в 2 раза
 *
 * Корзина это ячейка массива с индексом элемента равного ХешКоду ключа по формуле.
 * В каждом элементе этого массива(корзины) находится список в который помещаются
 * ключ и значение.
 *
 *
 * Ключ должен быть уникальным для этого надо переопределить методы HashCode и equals.
*
* Основные операции над Map
* myMap.put(key, value) - используется для довабления элемента, а также для обновления
* значения по ключу. Если элемент с таким ключом существует значение будет
* перезаписано иначе создасться новый элемент с таким ключом и значением.
* myMap.replace(key, value) - используется для замены значения по ключу. Отличается
* от put тем что, если такого ключа нет в нашей коллекции то ничего не произойдет.
* Если элемента с таким ключом не существует то вернет null.
* myMap.remove(key) - удаляет по ключу.
* myMap.entrySet() - возвращает Set Map.Entry<k,v>(возвращает коллекцию уникальных
* корзин с ключем и значением.)
* Можно так же использовать для простого обхода с помощью foreach.
* Для удаления таким сопособом надо получить итератор(указатель на текущую коризну)
* Iterator iter = myMap.entrySet().iterator();
* после чего можно удалять iter.remove() используя foreach
* myMap.keySet() - вернет set ключей.
* myMap.values() - вернет Collection значений.
* */
public class MainProgramm {
    public static void main(String[] args) {

        Map<Integer, String> map1 = new HashMap<Integer, String>();
        Map<Figure,Integer> map2 = new HashMap<Figure,Integer>();
        /*При добавлении элемента с тем же ключем значение будет
         * заменено. Для этого надо перегрузить методы queal и hashCode
         * для обьекта ключа*/
        map1.put(1, "ew");
        map1.replace(1, "eq");
        map1.put(2, "Test1");
        map1.put(3, "Test2");
        map1.put(4, "Test3");
        map1.put(5, "Test4");


        Set set = map1.entrySet();
        System.out.println(set);
        
        
        /*Выводим ключ и значение*/
        System.out.println("Выводим с помощью foreach Map.Entry");
        for (Map.Entry entry : map1.entrySet()) {
            System.out.println(entry);
        }



        /*Так же можно выводить отдельно значения или ключи*/
        for (String temp : map1.values()) {
        }
        for (Integer temp : map1.keySet()) {
        }


        /*удаление осуществляется через итератор и приведение
        * к EntrySet*/
        System.out.println("Выводим с помощью Iterator");
        Iterator iterator = map1.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> tempEntry2 = (Map.Entry) iterator.next();
            if (tempEntry2.getValue().equals("Test2"))
                iterator.remove();
        }


        System.out.println("/------------Пробую сделать коллизию---------------------/");
        map2.put(new Figure(4,6), 1);
        map2.put(new Figure(6,4), 2);
        map2.put(new Figure(4,6), 3);
        //что бы сделать коллизию достаточно не переопределить
        //hashcode или equals в классе figure
        System.out.println(map2);
        /*Выводим нашу мапу с коллизией*/
        for (Map.Entry temp : map2.entrySet()) {
            System.out.println(temp.getValue());
        }

        /*побитовые(поразрядные) это операции над двоичными числами
        * К примеру тут числа переводятся сначала в двоичное представление
        * а затем сравниваются поразрядно числа одного числа с другим.
        * 11110000 одно число, второе - 11111111
        * 1&1 = 1
        * 1&0 = 0
        * при сравнении двух чисел вверху получим 11110000
        * */

        System.out.println("пример побитовой операции: "+(2306996&15));
    }

}
